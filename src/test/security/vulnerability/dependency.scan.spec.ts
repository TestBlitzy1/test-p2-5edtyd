import { setupTestEnvironment } from '../../utils/test.helpers'; // @version ^1.0.0
import * as snyk from 'snyk'; // @version ^1.0.0
import { jest } from '@jest/globals'; // @version ^29.0.0

/**
 * Interface for vulnerability scan configuration
 */
interface ScanConfig {
  severityThreshold: 'low' | 'medium' | 'high' | 'critical';
  ignorePolicy?: boolean;
  allProjects?: boolean;
  failOnIssues?: boolean;
  showVulnPaths: 'none' | 'some' | 'all';
}

/**
 * Interface for vulnerability scan result
 */
interface ScanResult {
  vulnerabilities: Array<{
    id: string;
    title: string;
    severity: string;
    packageName: string;
    version: string;
    fixedIn: string[];
    cvssScore: number;
  }>;
  dependencyCount: number;
  licensesCount: number;
}

/**
 * Test suite for dependency vulnerability scanning
 */
class DependencyScanTest {
  private snykClient: typeof snyk;
  private scanHistory: ScanResult[];
  private readonly scanConfig: ScanConfig;

  constructor() {
    this.snykClient = snyk;
    this.scanHistory = [];
    this.scanConfig = {
      severityThreshold: 'high',
      ignorePolicy: false,
      allProjects: true,
      failOnIssues: true,
      showVulnPaths: 'some'
    };
  }

  /**
   * Performs comprehensive security scanning of project dependencies
   */
  private async scanDependencies(): Promise<ScanResult[]> {
    try {
      // Authenticate with Snyk
      await this.snykClient.config.set('api', process.env.SNYK_API_TOKEN);

      // Find all package.json files
      const packageFiles = await this.snykClient.test('.', {
        ...this.scanConfig,
        packageManager: 'npm'
      });

      // Process and normalize results
      const results = packageFiles.map(result => ({
        vulnerabilities: result.vulnerabilities.map(vuln => ({
          id: vuln.id,
          title: vuln.title,
          severity: vuln.severity,
          packageName: vuln.packageName,
          version: vuln.version,
          fixedIn: vuln.fixedIn || [],
          cvssScore: vuln.cvssScore
        })),
        dependencyCount: result.dependencyCount,
        licensesCount: result.licensesCount
      }));

      this.scanHistory.push(...results);
      return results;
    } catch (error) {
      console.error('Dependency scan failed:', error);
      throw error;
    }
  }

  /**
   * Analyzes scan results and categorizes vulnerabilities by severity
   */
  private analyzeSeverity(scanResults: ScanResult[]): {
    critical: number;
    high: number;
    medium: number;
    low: number;
    total: number;
  } {
    return scanResults.reduce((acc, result) => {
      result.vulnerabilities.forEach(vuln => {
        acc[vuln.severity.toLowerCase() as keyof typeof acc]++;
        acc.total++;
      });
      return acc;
    }, { critical: 0, high: 0, medium: 0, low: 0, total: 0 });
  }

  /**
   * Tests for presence of high and critical severity vulnerabilities
   */
  public async testHighSeverityVulnerabilities(): Promise<void> {
    const scanResults = await this.scanDependencies();
    const severityAnalysis = this.analyzeSeverity(scanResults);

    // Fail if any critical vulnerabilities are found
    expect(severityAnalysis.critical).toBe(0);

    // Warn if high severity vulnerabilities exist
    if (severityAnalysis.high > 0) {
      console.warn(`Found ${severityAnalysis.high} high severity vulnerabilities`);
    }

    // Log overall vulnerability statistics
    console.info('Vulnerability scan summary:', {
      total: severityAnalysis.total,
      critical: severityAnalysis.critical,
      high: severityAnalysis.high,
      medium: severityAnalysis.medium,
      low: severityAnalysis.low
    });
  }

  /**
   * Tests for outdated dependencies with security patches
   */
  public async testOutdatedDependencies(): Promise<void> {
    const scanResults = await this.scanDependencies();
    
    const outdatedDeps = scanResults.flatMap(result =>
      result.vulnerabilities
        .filter(vuln => vuln.fixedIn.length > 0)
        .map(vuln => ({
          package: vuln.packageName,
          currentVersion: vuln.version,
          fixedInVersion: vuln.fixedIn[0],
          severity: vuln.severity
        }))
    );

    // Fail if critical updates are pending
    const criticalUpdates = outdatedDeps.filter(dep => 
      dep.severity === 'critical'
    );
    
    expect(criticalUpdates).toHaveLength(0);

    // Log update recommendations
    if (outdatedDeps.length > 0) {
      console.warn('Dependencies requiring security updates:', outdatedDeps);
    }
  }

  /**
   * Tests license compliance of dependencies
   */
  public async testLicenseCompliance(): Promise<void> {
    const allowedLicenses = [
      'MIT', 'Apache-2.0', 'BSD-3-Clause', 'BSD-2-Clause', 'ISC'
    ];

    const scanResults = await this.scanDependencies();
    
    // Check for non-compliant licenses
    const licensesFound = new Set<string>();
    scanResults.forEach(result => {
      // Note: Actual license checking would require additional Snyk API calls
      // This is a simplified example
      if (result.licensesCount > 0) {
        licensesFound.add('Unknown License');
      }
    });

    const nonCompliantLicenses = Array.from(licensesFound)
      .filter(license => !allowedLicenses.includes(license));

    expect(nonCompliantLicenses).toHaveLength(0);
  }
}

describe('Dependency Security Scan', () => {
  let dependencyScan: DependencyScanTest;

  beforeAll(async () => {
    await setupTestEnvironment({
      dbConfig: {
        host: 'localhost',
        port: 5432,
        database: 'test_db',
        user: 'test_user',
        password: 'test_password'
      },
      mockServerPort: 3001
    });
    dependencyScan = new DependencyScanTest();
  });

  it('should not have any critical vulnerabilities', async () => {
    await dependencyScan.testHighSeverityVulnerabilities();
  });

  it('should not have outdated dependencies with security patches', async () => {
    await dependencyScan.testOutdatedDependencies();
  });

  it('should comply with license requirements', async () => {
    await dependencyScan.testLicenseCompliance();
  });
});

export { DependencyScanTest };